/*
 * Copyright 2014 Inderjit Gill
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.indy.seni.lang;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

/*
  seni reserves names beginning with $ for internal use

  ast generates gensym names for alterable nodes

  ast is immutable and shared by multiple instances of astHolder

  astHolder - mAst: ast
              list of alterable nodes and their values for this instance
              sets of valid values for names (based on which family they're in)
              will create the env and populate it with gensym names bound to appropriate values


 */

public class AstHolder {

    private List<Node> mAst;       // immutable and shared by multiple instances of astHolder
    private List<Node> mAlterable; // list of alterable nodes and their values for this instance

    public AstHolder(String code) {
        mAst = buildAst(code);
        // traverse the mAst for alterable nodes, add them into mAlterable
    }

    public AstHolder(AstHolder astHolder) {
        mAst = astHolder.mAst;
        // create a copy of mAlterable
    }

    public List<Node> getAlterable() {
        return mAlterable;
    }

    // todo: rename alterable to something more genetically accurate
    public Env addAlterableBindings(Env env) {
        Env e = env.newScope();
        
        for(Node n : mAlterable) {
            e.addBinding(n.getGenSym(), n);
        }

        return e;
    }

    public static class UglyCopyException extends Exception {
        public UglyCopyException(String message){
            super(message);
        }
    }
    /*
      TEMP: replace this with per-node class copy constructors
     */
    private Node uglyCopy(Node node) throws UglyCopyException {

        // can assume that any node passed here will be alterable
        // only have to deal with the node types generated by the parser

        try {
            Node.Type type = node.getType();

            if(type == Node.Type.BOOLEAN) {
                return new NodeBoolean(Node.asBooleanValue(node), true);
            }
            if(type == Node.Type.INT) {
                return new NodeInt(Node.asIntValue(node), true);
            }
            if(type == Node.Type.FLOAT) {
                return new NodeFloat(Node.asFloatValue(node), true);
            }
            if(type == Node.Type.NAME) {
                return new NodeName(Node.asNameValue(node), true);
            }
            if(type == Node.Type.STRING) {
                return new NodeString(Node.asStringValue(node), true);
            }
            if(type == Node.Type.LIST) {
                NodeList nl = new NodeList(true);
                for(Node n : Node.asList(node).getChildren()) {
                    nl.addChild(uglyCopy(n));
                }
                return nl;
            }
        } catch(LangException e) {
            e.printStackTrace();
        }

        throw new UglyCopyException(node.toString());
    }

    private void addGenSyms(Node node, SymbolGenerator sg) {

        try {
            if(node.isAlterable()) {
                String genSym = sg.gen();
                node.setGenSym(genSym);
                Node nodeCopy = uglyCopy(node);
                nodeCopy.setGenSym(genSym);
                mAlterable.add(nodeCopy);
            }
        } catch(UglyCopyException e) {
            e.printStackTrace();
        }
        
        try {
            if(node.getType() == Node.Type.LIST) {
                List<Node> children = Node.asList(node).getChildren();;
                for(Node n : children) {
                    addGenSyms(n, sg);
                }
            }
        } catch (LangException e) {
            e.printStackTrace();
        }
    }

    private List<Node> buildAst(String code) {

        try {
            Queue<Token> tokens = Lexer.tokenise(code);
            List<Node> ast = Parser.parse(tokens);

            // gensym alterable nodes in ast
            SymbolGenerator sg = new SymbolGenerator();
            mAlterable = new ArrayList<Node>();
            for(Node node : ast) {
                addGenSyms(node, sg);
            }
            
            return ast;
        } catch (LangException e) {
            e.printStackTrace();
        }

        return null;
    }
}
