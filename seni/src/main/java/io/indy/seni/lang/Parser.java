package io.indy.seni.lang;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Parser {

    public class ParserReturn {
        public List<Token> mTokens;    // the remaining tokens
        public Node mNode;

    }

    // TODO: replace List<Tokens> with Queue<Tokens>

    public ParserReturn consumeItem(List<Token> tokens) {
        if(tokens.size() == 0) {
            // raise error?
        }

        Token token = tokens.remove(0);

        Token.Type type = token.getType();
        if(type == Token.Type.LIST_START) {
            return consumeList(tokens);
        } else if(type == Token.Type.INT) {
            return consumeInt(token, tokens);
        } else if(type == Token.Type.FLOAT) {
            return consumeFloat(token, tokens);
        } else if(type == Token.Type.NAME) {
        } else if(type == Token.Type.STRING) {
        } else {
            // throw an error
        }
        return null;
    }

    public ParserReturn consumeList(List<Token> tokens) {

        // consume everything upto and including the LIST_END
        NodeList node = new NodeList();

        Token token;
        ParserReturn pr;

        while(true) {
            if(tokens.size() == 0) {
                // raise error?
            }
            token = tokens.get(0);
            if(token.getType() == Token.Type.LIST_END) {
                tokens.remove(0);
                pr = new ParserReturn();
                pr.mTokens = tokens;
                pr.mNode = node;
                return pr;
            } else {
                pr = consumeItem(tokens);
                tokens = pr.mTokens;
                node.addChild(pr.mNode);
            }
        }
    }


    private ParserReturn consumeInt(Token firstToken, List<Token> restTokens) {
        ParserReturn pr = new ParserReturn();
        pr.mNode = new NodeInt(firstToken.getIntValue());
        pr.mTokens = restTokens;
        return pr;
    }

    private ParserReturn consumeFloat(Token firstToken, List<Token> restTokens) {
        ParserReturn pr = new ParserReturn();
        pr.mNode = new NodeFloat(firstToken.getFloatValue());
        pr.mTokens = restTokens;
        return pr;
    }
}

/*
(ns seni.rt.lang.parser)

(declare consume-item)

(defn consume-list
  [lst]
  (if (not= :list-start (ffirst lst))
    ["error: not a list" lst nil]
    (loop [sub-lst (rest lst)
           sub-res []]
      (if (= :list-end (ffirst sub-lst))
        [nil (rest sub-lst) sub-res]
        (if (empty? sub-lst)
          ["error: mismatched parentheses" nil nil]
          (let [[err remaining-lst val] (consume-item sub-lst)]
            (if err
              [err nil nil]
              (recur remaining-lst (conj sub-res val)))))))))

(defn consume-item
  [lst]
  (if (empty? lst)
    [nil '(), '()]
    (if (= :list-start (ffirst lst))
      (consume-list lst)
      [nil (rest lst) (second (first lst))])))

(defn- remove-comments
  [lst]
  (remove #(= :comment (first %)) lst))

(defn parse
  "parse a list of tokens generated by lexing an input stream"
  [lst]
  (loop [[err ls res] (consume-item (remove-comments lst))
         overall-res []]
    (if err
      [err nil]
      (if (empty? ls)
        [nil (conj overall-res res)]
        (recur (consume-item ls)
               (conj overall-res res))))))


 */
